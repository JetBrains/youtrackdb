name: Check Commit Prefix

on:
  pull_request:
    types: [ opened, edited, synchronize, reopened ]

permissions:
  contents: read

jobs:
  check-commit-prefix:
    name: Verify commits contain issue prefix from PR title
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Check commit messages for issue prefix
        uses: actions/github-script@v8
        with:
          script: |
            const { execFileSync } = require('child_process');
            const prTitle = context.payload.pull_request.title;

            // Extract issue prefix from PR title (e.g., "YTDB-509" from "YTDB-509: Add feature")
            const prefixMatch = prTitle.match(/ytdb-(\d+)/i);

            if (!prefixMatch) {
              console.log(`PR title "${prTitle}" does not contain YTDB issue prefix. Skipping check.`);
              return;
            }

            const issuePrefix = `YTDB-${prefixMatch[1]}`;
            const issuePrefixLower = issuePrefix.toLowerCase();
            const baseBranch = context.payload.pull_request.base.ref;

            // Validate branch name to prevent command injection
            if (!/^[a-zA-Z0-9._\/-]+$/.test(baseBranch)) {
              core.setFailed(`Invalid base branch name: ${baseBranch}`);
              return;
            }

            console.log(`Found issue prefix: ${issuePrefix}`);
            console.log(`Base branch: ${baseBranch}`);

            // Find fork point: the merge base between the PR head and the base branch
            let mergeBase;
            try {
              mergeBase = execFileSync('git', ['merge-base', `origin/${baseBranch}`, 'HEAD']).toString().trim();
            } catch (e) {
              core.setFailed(`Failed to find merge-base between origin/${baseBranch} and HEAD: ${e.message}`);
              return;
            }
            console.log(`Fork point (merge-base): ${mergeBase.substring(0, 12)}`);

            // Get commits from fork point to HEAD (only PR-specific commits)
            // Use NUL byte as field separator for robust parsing
            let gitLog;
            try {
              gitLog = execFileSync('git', [
                'log', `--format=%H%x00%s%x00%P`, `${mergeBase}..HEAD`
              ]).toString().trim();
            } catch (e) {
              core.setFailed(`Failed to list commits: ${e.message}`);
              return;
            }

            if (!gitLog) {
              console.log('No commits found between fork point and HEAD.');
              return;
            }

            // Parse git log output: each line is SHA\0subject\0parents
            const commits = gitLog.split('\n').filter(l => l).map(line => {
              const [sha, message, parents] = line.split('\0');
              return {
                sha,
                message: message || '',
                parents: parents ? parents.split(' ') : []
              };
            });

            console.log(`Found ${commits.length} commit(s) between fork point and HEAD`);

            const failingCommits = [];
            const anyPrefixRegex = /ytdb-\d+/i;

            for (const commit of commits) {
              // Skip merge commits (they have more than one parent)
              if (commit.parents.length > 1) {
                console.log(`Skipping merge commit: ${commit.sha.substring(0, 7)}`);
                continue;
              }

              const messageLower = commit.message.toLowerCase();

              // Skip commits that reference a different YTDB issue (e.g., cherry-picked
              // from develop with different SHAs)
              if (!messageLower.includes(issuePrefixLower) && anyPrefixRegex.test(commit.message)) {
                console.log(`Skipping commit with different YTDB prefix: ${commit.sha.substring(0, 7)} - ${commit.message}`);
                continue;
              }

              if (!messageLower.includes(issuePrefixLower)) {
                failingCommits.push({
                  sha: commit.sha.substring(0, 7),
                  message: commit.message
                });
              }
            }

            if (failingCommits.length > 0) {
              console.log(`\n::error::Found ${failingCommits.length} commit(s) missing issue prefix "${issuePrefix}":`);
              for (const commit of failingCommits) {
                console.log(`  - ${commit.sha}: ${commit.message}`);
              }
              console.log(`\nAll commits must contain the issue prefix "${issuePrefix}" somewhere in the message.`);
              console.log(`To prevent this in the future, use the prepare-commit-msg hook.`);
              core.setFailed(`${failingCommits.length} commit(s) missing issue prefix "${issuePrefix}"`);
            } else {
              console.log(`\nâœ“ All ${commits.length} commit(s) contain the issue prefix "${issuePrefix}"`);
            }
