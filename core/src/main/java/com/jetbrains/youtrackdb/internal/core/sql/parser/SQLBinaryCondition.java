/* Generated By:JJTree: Do not edit this line. SQLBinaryCondition.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=true,NODE_PREFIX=O,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.jetbrains.youtrackdb.internal.core.sql.parser;

import com.jetbrains.youtrackdb.internal.core.command.CommandContext;
import com.jetbrains.youtrackdb.internal.core.db.DatabaseSessionEmbedded;
import com.jetbrains.youtrackdb.internal.core.db.record.record.Identifiable;
import com.jetbrains.youtrackdb.internal.core.exception.BaseException;
import com.jetbrains.youtrackdb.internal.core.exception.CommandExecutionException;
import com.jetbrains.youtrackdb.internal.core.metadata.schema.SchemaClassInternal;
import com.jetbrains.youtrackdb.internal.core.metadata.schema.schema.SchemaClass;
import com.jetbrains.youtrackdb.internal.core.query.Result;
import com.jetbrains.youtrackdb.internal.core.sql.executor.IndexSearchInfo;
import com.jetbrains.youtrackdb.internal.core.sql.executor.ResultInternal;
import com.jetbrains.youtrackdb.internal.core.sql.executor.metadata.IndexCandidate;
import com.jetbrains.youtrackdb.internal.core.sql.executor.metadata.IndexFinder;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;

public final class SQLBinaryCondition extends SQLBooleanExpression {

  SQLExpression left;
  SQLBinaryCompareOperator operator;
  SQLExpression right;

  public SQLBinaryCondition(int id) {
    super(id);
  }

  public SQLBinaryCondition(YouTrackDBSql p, int id) {
    super(p, id);
  }

  @Override
  public boolean evaluate(Identifiable currentRecord, CommandContext ctx) {
    return operator.execute(ctx.getDatabaseSession(), left.execute(currentRecord, ctx),
        right.execute(currentRecord, ctx));
  }

  @Override
  public boolean evaluate(Result currentRecord, CommandContext ctx) {
    if (left.isFunctionAny()) {
      return evaluateAny(currentRecord, ctx);
    }

    if (left.isFunctionAll()) {
      return evaluateAllFunction(currentRecord, ctx);
    }
    var leftVal = left.execute(currentRecord, ctx);
    var rightVal = right.execute(currentRecord, ctx);
    var collate = left.getCollate(currentRecord, ctx);
    if (collate == null) {
      collate = right.getCollate(currentRecord, ctx);
    }
    if (collate != null) {
      leftVal = collate.transform(leftVal);
      rightVal = collate.transform(rightVal);
    }
    return operator.execute(ctx.getDatabaseSession(), leftVal, rightVal);
  }

  private boolean evaluateAny(Result currentRecord, CommandContext ctx) {
    for (var s : currentRecord.getPropertyNames()) {
      var leftVal = currentRecord.getProperty(s);
      var rightVal = right.execute(currentRecord, ctx);

      // TODO collate

      if (operator.execute(ctx.getDatabaseSession(), leftVal, rightVal)) {
        return true;
      }
    }
    return false;
  }

  private boolean evaluateAllFunction(Result currentRecord, CommandContext ctx) {
    for (var s : currentRecord.getPropertyNames()) {
      var leftVal = currentRecord.getProperty(s);
      var rightVal = right.execute(currentRecord, ctx);

      // TODO collate

      if (!operator.execute(ctx.getDatabaseSession(), leftVal, rightVal)) {
        return false;
      }
    }
    return true;
  }

  @Override
  public void toString(Map<Object, Object> params, StringBuilder builder) {
    left.toString(params, builder);
    builder.append(" ");
    builder.append(operator.toString());
    builder.append(" ");
    right.toString(params, builder);
  }

  @Override
  public void toGenericStatement(StringBuilder builder) {
    left.toGenericStatement(builder);
    builder.append(" ");
    operator.toGenericStatement(builder);
    builder.append(" ");
    right.toGenericStatement(builder);
  }

  @Override
  protected boolean supportsBasicCalculation() {
    if (!operator.supportsBasicCalculation()) {
      return false;
    }
    return left.supportsBasicCalculation() && right.supportsBasicCalculation();
  }

  @Override
  protected int getNumberOfExternalCalculations() {
    var total = 0;
    if (!operator.supportsBasicCalculation()) {
      total++;
    }
    if (!left.supportsBasicCalculation()) {
      total++;
    }
    if (!right.supportsBasicCalculation()) {
      total++;
    }
    return total;
  }

  @Override
  protected List<Object> getExternalCalculationConditions() {
    List<Object> result = new ArrayList<Object>();
    if (!operator.supportsBasicCalculation()) {
      result.add(this);
    }
    if (!left.supportsBasicCalculation()) {
      result.add(left);
    }
    if (!right.supportsBasicCalculation()) {
      result.add(right);
    }
    return result;
  }

  public long estimateIndexed(SQLFromClause target, CommandContext context) {
    return left.estimateIndexedFunction(
        target, context, operator, right.execute((Result) null, context));
  }

  public Iterable<Identifiable> executeIndexedFunction(
      SQLFromClause target, CommandContext context) {
    return left.executeIndexedFunction(
        target, context, operator, right.execute((Result) null, context));
  }

  /**
   * tests if current expression involves an indexed funciton AND that function can also be executed
   * without using the index
   *
   * @param target  the query target
   * @param context the execution context
   * @return true if current expression involves an indexed function AND that function can be used
   * on this target, false otherwise
   */
  public boolean canExecuteIndexedFunctionWithoutIndex(
      SQLFromClause target, CommandContext context) {
    return left.canExecuteIndexedFunctionWithoutIndex(
        target, context, operator, right.execute((Result) null, context));
  }

  /**
   * tests if current expression involves an indexed function AND that function can be used on this
   * target
   *
   * @param target  the query target
   * @param context the execution context
   * @return true if current expression involves an indexed function AND that function can be used
   * on this target, false otherwise
   */
  public boolean allowsIndexedFunctionExecutionOnTarget(
      SQLFromClause target, CommandContext context) {
    return left.allowsIndexedFunctionExecutionOnTarget(
        target, context, operator, right.execute((Result) null, context));
  }

  /**
   * tests if current expression involves an indexed function AND the function has also to be
   * executed after the index search. In some cases, the index search is accurate, so this condition
   * can be excluded from further evaluation. In other cases the result from the index is a superset
   * of the expected result, so the function has to be executed anyway for further filtering
   *
   * @param target  the query target
   * @param context the execution context
   * @return true if current expression involves an indexed function AND the function has also to be
   * executed after the index search.
   */
  public boolean executeIndexedFunctionAfterIndexSearch(
      SQLFromClause target, CommandContext context) {
    return left.executeIndexedFunctionAfterIndexSearch(
        target, context, operator, right.execute((Result) null, context));
  }

  @Override
  @Nullable
  public List<SQLBinaryCondition> getIndexedFunctionConditions(
      SchemaClass iSchemaClass, DatabaseSessionEmbedded session) {
    if (left.isIndexedFunctionCal(session)) {
      return Collections.singletonList(this);
    }
    return null;
  }

  @Override
  public boolean needsAliases(Set<String> aliases) {
    if (left.needsAliases(aliases)) {
      return true;
    }
    return right.needsAliases(aliases);
  }

  @Override
  public SQLBinaryCondition copy() {
    var result = new SQLBinaryCondition(-1);
    result.left = left.copy();
    result.operator = operator.copy();
    result.right = right.copy();
    return result;
  }

  @Override
  public void extractSubQueries(SubQueryCollector collector) {
    left.extractSubQueries(collector);
    right.extractSubQueries(collector);
  }

  @Override
  public boolean refersToParent() {
    return left.refersToParent() || right.refersToParent();
  }

  @Override
  public Optional<SQLUpdateItem> transformToUpdateItem() {
    if (!checkCanTransformToUpdate()) {
      return Optional.empty();
    }
    if (operator instanceof SQLEqualsOperator) {
      var result = new SQLUpdateItem(-1);
      result.operator = SQLUpdateItem.OPERATOR_EQ;
      var baseExp = ((SQLBaseExpression) left.mathExpression);
      result.left = baseExp.getIdentifier().suffix.getIdentifier().copy();
      result.leftModifier = baseExp.modifier == null ? null : baseExp.modifier.copy();
      result.right = right.copy();
      return Optional.of(result);
    }
    return super.transformToUpdateItem();
  }

  private boolean checkCanTransformToUpdate() {
    if (left == null
        || left.mathExpression == null
        || !(left.mathExpression instanceof SQLBaseExpression base)) {
      return false;
    }
    return base.getIdentifier() != null
        && base.getIdentifier().suffix != null
        && base.getIdentifier().suffix.getIdentifier() != null;
  }

  public SQLExpression getLeft() {
    return left;
  }

  public SQLBinaryCompareOperator getOperator() {
    return operator;
  }

  public SQLExpression getRight() {
    return right;
  }

  public void setLeft(SQLExpression left) {
    this.left = left;
  }

  public void setOperator(SQLBinaryCompareOperator operator) {
    this.operator = operator;
  }

  public void setRight(SQLExpression right) {
    this.right = right;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }

    var that = (SQLBinaryCondition) o;

    if (!Objects.equals(left, that.left)) {
      return false;
    }
    if (!Objects.equals(operator, that.operator)) {
      return false;
    }
    return Objects.equals(right, that.right);
  }

  @Override
  public int hashCode() {
    var result = left != null ? left.hashCode() : 0;
    result = 31 * result + (operator != null ? operator.hashCode() : 0);
    result = 31 * result + (right != null ? right.hashCode() : 0);
    return result;
  }

  @Override
  public List<String> getMatchPatternInvolvedAliases() {
    var leftX = left.getMatchPatternInvolvedAliases();
    var rightX = right.getMatchPatternInvolvedAliases();
    if (leftX == null) {
      return rightX;
    }
    if (rightX == null) {
      return leftX;
    }

    List<String> result = new ArrayList<String>();
    result.addAll(leftX);
    result.addAll(rightX);
    return result;
  }

  @Override
  public void translateLuceneOperator() {
    if (operator instanceof SQLLuceneOperator) {
      var newLeft = new SQLExpression(-1);
      newLeft.mathExpression = new SQLBaseExpression(-1);
      var identifirer = new SQLBaseIdentifier(-1);
      ((SQLBaseExpression) newLeft.mathExpression).setIdentifier(identifirer);
      identifirer.levelZero = new SQLLevelZeroIdentifier(-1);
      var function = new SQLFunctionCall(-1);
      identifirer.levelZero.functionCall = function;
      function.name = new SQLIdentifier("search_fields");
      function.params = new ArrayList<>();
      function.params.add(fieldNamesToStrings(left));
      function.params.add(right);
      left = newLeft;

      operator = new SQLEqualsOperator(-1);
      right = new SQLExpression(-1);
      right.booleanValue = true;
    }
  }

  private static SQLExpression fieldNamesToStrings(SQLExpression left) {
    if (left.isBaseIdentifier()) {
      var identifier =
          ((SQLBaseExpression) left.mathExpression).getIdentifier().suffix.getIdentifier();
      var newColl = new SQLCollection(-1);
      newColl.expressions = new ArrayList<>();
      newColl.expressions.add(identifierToStringExpr(identifier));
      var result = new SQLExpression(-1);
      var newBase = new SQLBaseExpression(-1);
      result.mathExpression = newBase;
      var newIdentifier = new SQLBaseIdentifier(-1);
      newIdentifier.levelZero = new SQLLevelZeroIdentifier(-1);
      newIdentifier.levelZero.collection = newColl;
      newBase.setIdentifier(newIdentifier);
      return result;
    } else if (left.mathExpression instanceof SQLBaseExpression base) {
      if (base.getIdentifier() != null
          && base.getIdentifier().levelZero != null
          && base.getIdentifier().levelZero.collection != null) {
        var coll = base.getIdentifier().levelZero.collection;

        var newColl = new SQLCollection(-1);
        newColl.expressions = new ArrayList<>();

        for (var exp : coll.expressions) {
          if (exp.isBaseIdentifier()) {
            var identifier =
                ((SQLBaseExpression) exp.mathExpression).getIdentifier().suffix.getIdentifier();
            var val = identifierToStringExpr(identifier);
            newColl.expressions.add(val);
          } else {
            throw new CommandExecutionException(
                "Cannot execute because of invalid LUCENE expression");
          }
        }
        var result = new SQLExpression(-1);
        var newBase = new SQLBaseExpression(-1);
        result.mathExpression = newBase;
        var newIdentifier = new SQLBaseIdentifier(-1);
        newIdentifier.levelZero = new SQLLevelZeroIdentifier(-1);
        newIdentifier.levelZero.collection = newColl;
        newBase.setIdentifier(newIdentifier);
        return result;
      }
    }
    throw new CommandExecutionException("Cannot execute because of invalid LUCENE expression");
  }

  private static SQLExpression identifierToStringExpr(SQLIdentifier identifier) {
    var bexp = new SQLBaseExpression(identifier.getStringValue());

    var result = new SQLExpression(-1);
    result.mathExpression = bexp;
    return result;
  }

  @Override
  public Result serialize(DatabaseSessionEmbedded session) {
    var result = new ResultInternal(session);
    result.setProperty("left", left.serialize(session));
    result.setProperty("operator", operator.getClass().getName());
    result.setProperty("right", right.serialize(session));
    return result;
  }

  @Override
  public void deserialize(Result fromResult) {
    left = new SQLExpression(-1);
    left.deserialize(fromResult.getProperty("left"));
    try {
      operator =
          (SQLBinaryCompareOperator)
              Class.forName(String.valueOf(fromResult.getProperty("operator"))).newInstance();
    } catch (Exception e) {
      throw BaseException.wrapException(new CommandExecutionException(""), e, (String) null);
    }
    right = new SQLExpression(-1);
    right.deserialize(fromResult.getProperty("right"));
  }

  @Override
  public boolean isCacheable(DatabaseSessionEmbedded session) {
    return left.isCacheable(session) && right.isCacheable(session);
  }

  @Override
  public SQLBooleanExpression rewriteIndexChainsAsSubqueries(CommandContext ctx,
      SchemaClassInternal clazz) {
    if (operator instanceof SQLEqualsOperator
        && right.isEarlyCalculated(ctx)
        && left.isIndexChain(ctx, clazz)) {
      var result = new SQLInCondition(-1);

      result.left = new SQLExpression(-1);
      var base = new SQLBaseExpression(-1);
      var identifier = new SQLBaseIdentifier(-1);
      identifier.suffix = new SQLSuffixIdentifier(-1);
      identifier.suffix.setIdentifier(
          ((SQLBaseExpression) left.mathExpression).getIdentifier().suffix.getIdentifier());
      base.setIdentifier(identifier);
      result.left.mathExpression = base;

      result.operator = new SQLInOperator(-1);

      var session = ctx.getDatabaseSession();
      var nextClazz =
          clazz
              .getProperty(
                  base.getIdentifier().suffix.getIdentifier().getStringValue())
              .getLinkedClass();
      result.rightStatement =
          indexChainToStatement(
              ((SQLBaseExpression) left.mathExpression).modifier, nextClazz, right, ctx);
      return result;
    }
    return this;
  }

  public static SQLSelectStatement indexChainToStatement(
      SQLModifier modifier, SchemaClass clazz, SQLExpression right, CommandContext ctx) {

    var result = new SQLSelectStatement(-1);
    result.target = new SQLFromClause(-1);
    result.target.setItem(new SQLFromItem(-1));
    result.target.getItem().identifier = new SQLIdentifier(
        clazz.getName());

    result.whereClause = new SQLWhereClause(-1);
    var base = new SQLBinaryCondition(-1);
    result.whereClause.baseExpression = new SQLNotBlock(-1);
    ((SQLNotBlock) result.whereClause.baseExpression).sub = base;
    ((SQLNotBlock) result.whereClause.baseExpression).negate = false;

    base.left = new SQLExpression(-1);
    base.left.mathExpression = new SQLBaseExpression(-1);
    ((SQLBaseExpression) base.left.mathExpression)
        .setIdentifier(new SQLBaseIdentifier(modifier.suffix.getIdentifier()));
    ((SQLBaseExpression) base.left.mathExpression).modifier =
        modifier.next == null ? null : modifier.next.copy();

    base.operator = new SQLEqualsOperator(-1);
    base.right = right.copy();

    return result;
  }

  @Override
  @Nullable
  public IndexCandidate findIndex(IndexFinder info, CommandContext ctx) {
    var path = left.getIndexMetadataPath(ctx.getDatabaseSession());
    if (path != null) {
      if (right.isEarlyCalculated(ctx)) {
        var value = right.execute((Result) null, ctx);
        if (operator instanceof SQLEqualsOperator) {
          return info.findExactIndex(path, value, ctx);
        } else if (operator instanceof SQLContainsKeyOperator) {
          return info.findByKeyIndex(path, value, ctx);
        } else if (operator.isRangeOperator()) {
          return info.findAllowRangeIndex(path, operator.getOperation(), value, ctx);
        }
      }
    }

    return null;
  }

  @Override
  public List<SQLAndBlock> flatten(CommandContext ctx, @Nullable SchemaClassInternal schemaClass) {
    var session = ctx.getDatabaseSession();

    //usage of indexes for the case when the graph navigation function is used
    //and properties that are used for relations in entities are indexed.
    if (left != null && left.isGraphNavigationFunction(session) && schemaClass != null) {
      //extract all properties used for navigation in the graph and merge them
      // by 'or' condition.
      var propertiesToFlatten = left.getGraphRelationProperties(ctx, schemaClass);

      if (propertiesToFlatten != null) {
        var result = new ArrayList<SQLAndBlock>(propertiesToFlatten.size());

        for (var propertyName : propertiesToFlatten) {
          var block = new SQLAndBlock(-1);

          var newCondition = new SQLBinaryCondition(-1);

          //This expression allows directly use property for navigation in the graph
          //if we use public API instead, we would get an exception as edges
          //are not allowed to be manipulated directly.
          newCondition.left = new SQLGetInternalPropertyExpression(propertyName);
          newCondition.operator = operator != null ? operator.copy() : null;
          newCondition.right = right != null ? right.copy() : null;

          block.subBlocks.add(newCondition);

          result.add(block);
        }

        return result;
      }
    }

    return super.flatten(ctx, schemaClass);
  }

  @Override
  public boolean isIndexAware(IndexSearchInfo info, CommandContext ctx) {
    if (left.isBaseIdentifier()) {
      if (info.fieldName().equals(left.getDefaultAlias().getStringValue())) {
        if (right.isEarlyCalculated(info.ctx())) {
          if (operator instanceof SQLEqualsOperator) {
            return true;
          } else if (operator instanceof SQLContainsKeyOperator
              && info.isMap()
              && info.indexedByKey()) {
            return true;
          } else {
            return info.allowsRangeQueries() && operator.isRangeOperator();
          }
        }
      }
    }

    return false;
  }

  @Override
  public boolean isRangeExpression() {
    return operator != null && operator.isRangeOperator();
  }

  @Nullable
  @Override
  public String getRelatedIndexPropertyName() {
    if (left.isBaseIdentifier()) {
      return left.getDefaultAlias().getStringValue();
    }

    return null;
  }

  @Override
  public boolean canCreateRangeWith(SQLBooleanExpression match) {
    if (!(match instanceof SQLBinaryCondition matchingCondition)) {
      return false;
    }
    if (!matchingCondition.left.equals(this.left)) {
      return false;
    }
    var leftOperator = matchingCondition.operator;
    var rightOperator = this.operator;
    if (leftOperator instanceof SQLGeOperator || leftOperator instanceof SQLGtOperator) {
      return rightOperator instanceof SQLLeOperator || rightOperator instanceof SQLLtOperator;
    }
    if (leftOperator instanceof SQLLeOperator || leftOperator instanceof SQLLtOperator) {
      return rightOperator instanceof SQLGeOperator || rightOperator instanceof SQLGtOperator;
    }
    return false;
  }

  @Nullable
  @Override
  public SQLExpression resolveKeyFrom(SQLBinaryCondition additional) {
    var operator = this.operator;
    if ((operator instanceof SQLEqualsOperator)
        || (operator instanceof SQLGtOperator)
        || (operator instanceof SQLGeOperator)
        || (operator instanceof SQLContainsKeyOperator)
        || (operator instanceof SQLContainsValueOperator)) {
      return right;
    } else if (additional != null) {
      return additional.right;
    } else {
      return null;
    }
  }

  @Nullable
  @Override
  public SQLExpression resolveKeyTo(SQLBinaryCondition additional) {
    var operator = this.operator;
    if ((operator instanceof SQLEqualsOperator)
        || (operator instanceof SQLLtOperator)
        || (operator instanceof SQLLeOperator)
        || (operator instanceof SQLContainsKeyOperator)
        || (operator instanceof SQLContainsValueOperator)) {
      return right;
    } else if (additional != null) {
      return additional.right;
    } else {
      return null;
      //      throw new UnsupportedOperationException("Cannot execute index query with " + this);
    }
  }

  @Nullable
  @Override
  public SQLBooleanExpression mergeUsingAnd(SQLBooleanExpression other,
      @Nonnull CommandContext ctx) {
    if (other instanceof SQLBinaryCondition otherCondition) {
      if (!left.isBaseIdentifier() && !right.isEarlyCalculated(ctx)) {
        return null;
      }

      var otherLeft = otherCondition.left;

      if (!left.equals(otherLeft)) {
        return null;
      }

      var otherRightValue = otherCondition.right.execute((Result) null, ctx);
      var rightValue = right.execute((Result) null, ctx);

      var resultOperand = operator.mergeWithOperator(ctx.getDatabaseSession(),
          otherCondition.operator,
          rightValue,
          otherRightValue);

      if (resultOperand != null) {
        var result = new SQLBinaryCondition(-1);
        result.left = left.copy();
        result.operator = operator.copy();
        result.right = new SQLValueExpression(resultOperand);

        return result;
      }
    }

    return null;
  }

  @Override
  public boolean varMightBeInUse(String varName) {
    return left.varMightBeInUse(varName) || right.varMightBeInUse(varName);
  }
}
/* JavaCC - OriginalChecksum=99ed1dd2812eb730de8e1931b1764da5 (do not edit this line) */
