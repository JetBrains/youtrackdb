/* Generated By:JJTree: Do not edit this line. SQLMatchStatement.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=true,NODE_PREFIX=O,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.jetbrains.youtrackdb.internal.core.sql.parser;

import com.jetbrains.youtrackdb.internal.core.command.BasicCommandContext;
import com.jetbrains.youtrackdb.internal.core.command.CommandContext;
import com.jetbrains.youtrackdb.internal.core.db.DatabaseSessionEmbedded;
import com.jetbrains.youtrackdb.internal.core.db.record.record.Identifiable;
import com.jetbrains.youtrackdb.internal.core.exception.CommandExecutionException;
import com.jetbrains.youtrackdb.internal.core.metadata.schema.schema.Schema;
import com.jetbrains.youtrackdb.internal.core.query.ResultSet;
import com.jetbrains.youtrackdb.internal.core.sql.executor.InternalExecutionPlan;
import com.jetbrains.youtrackdb.internal.core.sql.executor.match.MatchExecutionPlanner;
import com.jetbrains.youtrackdb.internal.core.sql.executor.match.PatternEdge;
import java.util.ArrayList;
import java.util.IdentityHashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.annotation.Nullable;

public final class SQLMatchStatement extends SQLStatement {

  static final String DEFAULT_ALIAS_PREFIX = "$YOUTRACKDB_DEFAULT_ALIAS_";

  public static final String KEYWORD_MATCH = "MATCH";
  // parsed data
  private List<SQLMatchExpression> matchExpressions = new ArrayList<>();
  private List<SQLMatchExpression> notMatchExpressions = new ArrayList<>();
  private List<SQLExpression> returnItems = new ArrayList<>();
  private List<SQLIdentifier> returnAliases = new ArrayList<>();
  private List<SQLNestedProjection> returnNestedProjections = new ArrayList<>();
  boolean returnDistinct = false;
  SQLGroupBy groupBy;
  SQLOrderBy orderBy;
  SQLUnwind unwind;
  SQLSkip skip;
  SQLLimit limit;

  // post-parsing generated data
  Pattern pattern;

  Map<String, SQLWhereClause> aliasFilters;

  // execution data
  private CommandContext context;

  public List<SQLNestedProjection> getReturnNestedProjections() {
    return returnNestedProjections;
  }

  public void setContext(CommandContext context) {
    this.context = context;
  }

  public void setReturnNestedProjections(List<SQLNestedProjection> returnNestedProjections) {
    this.returnNestedProjections = returnNestedProjections;
  }

  public void addMatchExpression(SQLMatchExpression exp) {
    this.matchExpressions.add(exp);
  }

  public void addNotMatchExpression(SQLMatchExpression exp) {
    this.notMatchExpressions.add(exp);
  }

  public void addReturnNestedProjection(SQLNestedProjection projection) {
    this.returnNestedProjections.add(projection);
  }

  public void addReturnItem(SQLExpression item) {
    this.returnItems.add(item);
  }

  public void addReturnAlias(SQLIdentifier alias) {
    this.returnAliases.add(alias);
  }

  /**
   * Per-row match state used during legacy traversal. Carries the set of matched
   * aliases and their candidate record sets for a single result row.
   */
  public static class MatchContext {

    int currentEdgeNumber = 0;

    LinkedHashMap<Object, Iterable<Identifiable>> candidates = new LinkedHashMap<>();
    Map<String, Identifiable> matched = new LinkedHashMap<>();
    Map<PatternEdge, Boolean> matchedEdges = new IdentityHashMap<>();

    public MatchContext copy(String alias, Identifiable value) {
      var result = new MatchContext();

      result.candidates.putAll(candidates);
      result.candidates.remove(alias);

      result.matched.putAll(matched);
      result.matched.put(alias, value);

      result.matchedEdges.putAll(matchedEdges);
      result.currentEdgeNumber = currentEdgeNumber;
      return result;
    }
  }

  public SQLMatchStatement() {
    super(-1);
  }

  public SQLMatchStatement(int id) {
    super(id);
  }

  public SQLMatchStatement(YouTrackDBSql p, int id) {
    super(p, id);
  }

  @Override
  public ResultSet execute(
      DatabaseSessionEmbedded session, Object[] args, CommandContext parentCtx,
      boolean usePlanCache) {
    var ctx = new BasicCommandContext();
    if (parentCtx != null) {
      ctx.setParentWithoutOverridingChild(parentCtx);
    }
    ctx.setDatabaseSession(session);
    Map<Object, Object> params = new java.util.HashMap<>();
    if (args != null) {
      for (var i = 0; i < args.length; i++) {
        params.put(i, args[i]);
      }
    }
    ctx.setInputParameters(params);
    InternalExecutionPlan executionPlan;
    if (usePlanCache) {
      executionPlan = createExecutionPlan(ctx, false);
    } else {
      executionPlan = createExecutionPlanNoCache(ctx, false);
    }

    return new LocalResultSet(session, executionPlan);
  }

  @Override
  public ResultSet execute(
      DatabaseSessionEmbedded session, Map<Object, Object> params, CommandContext parentCtx,
      boolean usePlanCache) {
    var ctx = new BasicCommandContext();
    if (parentCtx != null) {
      ctx.setParentWithoutOverridingChild(parentCtx);
    }
    ctx.setDatabaseSession(session);
    ctx.setInputParameters(params);
    InternalExecutionPlan executionPlan;
    if (usePlanCache) {
      executionPlan = createExecutionPlan(ctx, false);
    } else {
      executionPlan = createExecutionPlanNoCache(ctx, false);
    }

    return new LocalResultSet(session, executionPlan);
  }

  @Override
  public boolean executinPlanCanBeCached(DatabaseSessionEmbedded session) {
    if (originalStatement == null) {
      setOriginalStatement(this.toString());
    }
    for (var expr : matchExpressions) {
      if (!expr.isCacheable(session)) {
        return false;
      }
    }
    for (var expr : notMatchExpressions) {
      if (!expr.isCacheable(session)) {
        return false;
      }
    }
    for (var item : returnItems) {
      if (!item.isCacheable(session)) {
        return false;
      }
    }
    return true;
  }

  @Override
  public InternalExecutionPlan createExecutionPlan(CommandContext ctx, boolean enableProfiling) {
    var planner = new MatchExecutionPlanner(this);
    var result = planner.createExecutionPlan(ctx, enableProfiling, true);
    result.setStatement(originalStatement);
    result.setGenericStatement(this.toGenericStatement());
    return result;
  }

  @Override
  public InternalExecutionPlan createExecutionPlanNoCache(
      CommandContext ctx, boolean enableProfiling) {
    var planner = new MatchExecutionPlanner(this);
    var result = planner.createExecutionPlan(ctx, enableProfiling, false);
    result.setStatement(originalStatement);
    result.setGenericStatement(this.toGenericStatement());
    return result;
  }

  // ------------------------------------------------------------------
  // query parsing and optimization
  // ------------------------------------------------------------------
  void buildPatterns() {
    assignDefaultAliases(this.matchExpressions);
    pattern = new Pattern();
    for (var expr : this.matchExpressions) {
      pattern.addExpression(expr);
    }

    Map<String, SQLWhereClause> aliasFilters = new LinkedHashMap<>();
    Map<String, String> aliasClasses = new LinkedHashMap<>();
    for (var expr : this.matchExpressions) {
      addAliases(expr, aliasFilters, aliasClasses, context);
    }

    this.aliasFilters = aliasFilters;

    rebindFilters(aliasFilters);
  }

  /**
   * rebinds filter (where) conditions to alias nodes after optimization
   */
  private void rebindFilters(Map<String, SQLWhereClause> aliasFilters) {
    for (var expression : matchExpressions) {
      var newFilter = aliasFilters.get(expression.origin.getAlias());
      expression.origin.setFilter(newFilter);

      for (var item : expression.items) {
        newFilter = aliasFilters.get(item.filter.getAlias());
        item.filter.setFilter(newFilter);
      }
    }
  }

  /**
   * assigns default aliases to pattern nodes that do not have an explicit alias
   */
  static void assignDefaultAliases(List<SQLMatchExpression> matchExpressions) {
    var counter = 0;
    for (var expression : matchExpressions) {
      if (expression.origin.getAlias() == null) {
        expression.origin.setAlias(DEFAULT_ALIAS_PREFIX + (counter++));
      }

      for (var item : expression.items) {
        if (item.filter == null) {
          item.filter = new SQLMatchFilter(-1);
        }
        if (item.filter.getAlias() == null) {
          item.filter.setAlias(DEFAULT_ALIAS_PREFIX + (counter++));
        }
      }
    }
    assert SQLMatchAssertions.allAliasesAssigned(matchExpressions);
  }

  public boolean returnsPathElements() {
    for (var item : returnItems) {
      if (item.toString().equalsIgnoreCase("$pathElements")) {
        return true;
      }
    }
    return false;
  }

  public boolean returnsElements() {
    for (var item : returnItems) {
      if (item.toString().equalsIgnoreCase("$elements")) {
        return true;
      }
    }
    return false;
  }

  public boolean returnsPatterns() {
    for (var item : returnItems) {
      if (item.toString().equalsIgnoreCase("$patterns")) {
        return true;
      }
      if (item.toString().equalsIgnoreCase("$matches")) {
        return true;
      }
    }
    return false;
  }

  public boolean returnsPaths() {
    for (var item : returnItems) {
      if (item.toString().equalsIgnoreCase("$paths")) {
        return true;
      }
    }
    return false;
  }


  private static void addAliases(
      SQLMatchExpression expr,
      Map<String, SQLWhereClause> aliasFilters,
      Map<String, String> aliasClasses,
      CommandContext context) {
    addAliases(expr.origin, aliasFilters, aliasClasses, context);
    for (var item : expr.items) {
      if (item.filter != null) {
        addAliases(item.filter, aliasFilters, aliasClasses, context);
      }
    }
  }

  private static void addAliases(
      SQLMatchFilter matchFilter,
      Map<String, SQLWhereClause> aliasFilters,
      Map<String, String> aliasClasses,
      CommandContext context) {
    var db = context.getDatabaseSession();
    var alias = matchFilter.getAlias();
    var filter = matchFilter.getFilter();
    if (alias != null) {
      if (filter != null && filter.baseExpression != null) {
        var previousFilter = aliasFilters.get(alias);
        if (previousFilter == null) {
          previousFilter = new SQLWhereClause(-1);
          previousFilter.baseExpression = new SQLAndBlock(-1);
          aliasFilters.put(alias, previousFilter);
        }
        var filterBlock = (SQLAndBlock) previousFilter.baseExpression;
        if (filter.baseExpression != null) {
          filterBlock.subBlocks.add(filter.baseExpression);
        }
      }

      var clazz = matchFilter.getClassName(context);
      if (clazz != null) {
        var previousClass = aliasClasses.get(alias);
        if (previousClass == null) {
          aliasClasses.put(alias, clazz);
        } else {
          var lower = getLowerSubclass(db, clazz, previousClass);
          if (lower == null) {
            throw new CommandExecutionException(
                "classes defined for alias "
                    + alias
                    + " ("
                    + clazz
                    + ", "
                    + previousClass
                    + ") are not in the same hierarchy");
          }
          aliasClasses.put(alias, lower);
        }
      }
    }
  }

  @Nullable
  static String getLowerSubclass(DatabaseSessionEmbedded session, String className1,
      String className2) {
    assert SQLMatchAssertions.classNamesNotNull(className1, className2);
    Schema schema = session.getMetadata().getSchema();
    var class1 = schema.getClass(className1);
    var class2 = schema.getClass(className2);
    if (class1 == null) {
      throw new CommandExecutionException(session,
          "Class " + className1 + " not found in the schema");
    }
    if (class2 == null) {
      throw new CommandExecutionException(session,
          "Class " + className2 + " not found in the schema");
    }
    if (class1.isSubClassOf(class2)) {
      return class1.getName();
    }
    if (class2.isSubClassOf(class1)) {
      return class2.getName();
    }
    return null;
  }

  @Override
  public boolean isIdempotent() {
    return true;
  }

  @Override
  public void toString(Map<Object, Object> params, StringBuilder builder) {
    builder.append(KEYWORD_MATCH);
    builder.append(" ");
    var first = true;
    for (var expr : this.matchExpressions) {
      if (!first) {
        builder.append(", ");
      }
      expr.toString(params, builder);
      first = false;
    }
    builder.append(" RETURN ");
    if (returnDistinct) {
      builder.append("DISTINCT ");
    }
    first = true;
    var i = 0;
    for (var expr : this.returnItems) {
      if (!first) {
        builder.append(", ");
      }
      expr.toString(params, builder);
      if (returnNestedProjections != null
          && i < returnNestedProjections.size()
          && returnNestedProjections.get(i) != null) {
        returnNestedProjections.get(i).toString(params, builder);
      }
      if (returnAliases != null && i < returnAliases.size() && returnAliases.get(i) != null) {
        builder.append(" AS ");
        returnAliases.get(i).toString(params, builder);
      }
      i++;
      first = false;
    }
    if (groupBy != null) {
      builder.append(" ");
      groupBy.toString(params, builder);
    }
    if (orderBy != null) {
      builder.append(" ");
      orderBy.toString(params, builder);
    }
    if (unwind != null) {
      builder.append(" ");
      unwind.toString(params, builder);
    }
    if (skip != null) {
      builder.append(" ");
      skip.toString(params, builder);
    }
    if (limit != null) {
      builder.append(" ");
      limit.toString(params, builder);
    }
  }

  @Override
  public void toGenericStatement(StringBuilder builder) {
    builder.append(KEYWORD_MATCH);
    builder.append(" ");
    var first = true;
    for (var expr : this.matchExpressions) {
      if (!first) {
        builder.append(", ");
      }
      expr.toGenericStatement(builder);
      first = false;
    }
    builder.append(" RETURN ");
    if (returnDistinct) {
      builder.append("DISTINCT ");
    }
    first = true;
    var i = 0;
    for (var expr : this.returnItems) {
      if (!first) {
        builder.append(", ");
      }
      expr.toGenericStatement(builder);
      if (returnNestedProjections != null
          && i < returnNestedProjections.size()
          && returnNestedProjections.get(i) != null) {
        returnNestedProjections.get(i).toGenericStatement(builder);
      }
      if (returnAliases != null && i < returnAliases.size() && returnAliases.get(i) != null) {
        builder.append(" AS ");
        returnAliases.get(i).toGenericStatement(builder);
      }
      i++;
      first = false;
    }
    if (groupBy != null) {
      builder.append(" ");
      groupBy.toGenericStatement(builder);
    }
    if (orderBy != null) {
      builder.append(" ");
      orderBy.toGenericStatement(builder);
    }
    if (unwind != null) {
      builder.append(" ");
      unwind.toGenericStatement(builder);
    }
    if (skip != null) {
      builder.append(" ");
      skip.toGenericStatement(builder);
    }
    if (limit != null) {
      builder.append(" ");
      limit.toGenericStatement(builder);
    }
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }

    var that = (SQLMatchStatement) o;

    if (!Objects.equals(matchExpressions, that.matchExpressions)) {
      return false;
    }
    if (!Objects.equals(notMatchExpressions, that.notMatchExpressions)) {
      return false;
    }
    if (!Objects.equals(returnItems, that.returnItems)) {
      return false;
    }
    if (!Objects.equals(returnAliases, that.returnAliases)) {
      return false;
    }
    if (!Objects.equals(returnNestedProjections, that.returnNestedProjections)) {
      return false;
    }
    if (!Objects.equals(groupBy, that.groupBy)) {
      return false;
    }
    if (!Objects.equals(orderBy, that.orderBy)) {
      return false;
    }
    if (!Objects.equals(unwind, that.unwind)) {
      return false;
    }
    if (!Objects.equals(skip, that.skip)) {
      return false;
    }
    if (!Objects.equals(limit, that.limit)) {
      return false;
    }

    return returnDistinct == that.returnDistinct;
  }

  @Override
  public int hashCode() {
    var result = matchExpressions != null ? matchExpressions.hashCode() : 0;
    result = 31 * result + (notMatchExpressions != null ? notMatchExpressions.hashCode() : 0);
    result = 31 * result + (returnItems != null ? returnItems.hashCode() : 0);
    result = 31 * result + (returnAliases != null ? returnAliases.hashCode() : 0);
    result =
        31 * result + (returnNestedProjections != null ? returnNestedProjections.hashCode() : 0);
    result = 31 * result + (groupBy != null ? groupBy.hashCode() : 0);
    result = 31 * result + (orderBy != null ? orderBy.hashCode() : 0);
    result = 31 * result + (unwind != null ? unwind.hashCode() : 0);
    result = 31 * result + (skip != null ? skip.hashCode() : 0);
    result = 31 * result + (limit != null ? limit.hashCode() : 0);
    return result;
  }

  public SQLLimit getLimit() {
    return limit;
  }

  public void setLimit(SQLLimit limit) {
    this.limit = limit;
  }

  public List<SQLIdentifier> getReturnAliases() {
    return returnAliases;
  }

  public void setReturnAliases(List<SQLIdentifier> returnAliases) {
    this.returnAliases = returnAliases;
  }

  public List<SQLExpression> getReturnItems() {
    return returnItems;
  }

  public void setReturnItems(List<SQLExpression> returnItems) {
    this.returnItems = returnItems;
  }

  public List<SQLMatchExpression> getMatchExpressions() {
    return matchExpressions;
  }

  public void setMatchExpressions(List<SQLMatchExpression> matchExpressions) {
    this.matchExpressions = matchExpressions;
  }

  public List<SQLMatchExpression> getNotMatchExpressions() {
    return notMatchExpressions;
  }

  public void setNotMatchExpressions(List<SQLMatchExpression> notMatchExpressions) {
    this.notMatchExpressions = notMatchExpressions;
  }

  public boolean isReturnDistinct() {
    return returnDistinct;
  }

  public void setReturnDistinct(boolean returnDistinct) {
    this.returnDistinct = returnDistinct;
  }

  public SQLOrderBy getOrderBy() {
    return orderBy;
  }

  public void setOrderBy(SQLOrderBy orderBy) {
    this.orderBy = orderBy;
  }

  public SQLGroupBy getGroupBy() {
    return groupBy;
  }

  public void setGroupBy(SQLGroupBy groupBy) {
    this.groupBy = groupBy;
  }

  public SQLUnwind getUnwind() {
    return unwind;
  }

  public void setUnwind(SQLUnwind unwind) {
    this.unwind = unwind;
  }

  public SQLSkip getSkip() {
    return skip;
  }

  public void setSkip(SQLSkip skip) {
    this.skip = skip;
  }

  @Override
  public boolean refersToParent() {
    // TODO check this!
    return false;
  }
}
/* JavaCC - OriginalChecksum=6ff0afbe9d31f08b72159fcf24070c9f (do not edit this line) */
