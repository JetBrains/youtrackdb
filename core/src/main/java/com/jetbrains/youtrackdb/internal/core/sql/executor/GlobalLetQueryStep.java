package com.jetbrains.youtrackdb.internal.core.sql.executor;

import com.jetbrains.youtrackdb.internal.common.concur.TimeoutException;
import com.jetbrains.youtrackdb.internal.core.command.BasicCommandContext;
import com.jetbrains.youtrackdb.internal.core.command.CommandContext;
import com.jetbrains.youtrackdb.internal.core.query.ExecutionPlan;
import com.jetbrains.youtrackdb.internal.core.query.ExecutionStep;
import com.jetbrains.youtrackdb.internal.core.query.Result;
import com.jetbrains.youtrackdb.internal.core.sql.executor.resultset.ExecutionStream;
import com.jetbrains.youtrackdb.internal.core.sql.parser.LocalResultSet;
import com.jetbrains.youtrackdb.internal.core.sql.parser.SQLIdentifier;
import com.jetbrains.youtrackdb.internal.core.sql.parser.SQLStatement;
import com.jetbrains.youtrackdb.internal.core.sql.parser.SubQueryCollector;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Global LET step that executes a subquery <b>once</b> and stores the result set
 * as a context variable.
 *
 * <pre>
 *  SQL:  LET $topProducts = (SELECT FROM Product ORDER BY price DESC LIMIT 10)
 *        SELECT FROM Order WHERE product IN $topProducts
 *
 *  This step executes the subquery, collects results into a list, and stores
 *  them as ctx.variable("topProducts").
 * </pre>
 *
 * <p>A child {@link BasicCommandContext} is created for the subquery to isolate
 * its variables from the outer scope. Script variables from previously executed
 * LET steps are forwarded to the child context.
 *
 * <h2>Lazy vs materialized storage</h2>
 * The subquery result is stored either as a lazy {@code ResultSet} or as a
 * materialized {@code List<Result>}, depending on how the variable is used:
 * <ul>
 *   <li><b>Materialized (List)</b> when the variable was generated by
 *       {@code extractSubQueries()} (prefix {@code $$$SUBQUERY$$_}) or is
 *       referenced by the outer WHERE clause -- because it may be iterated
 *       multiple times (once per outer record).</li>
 *   <li><b>Lazy (ResultSet)</b> otherwise -- to avoid loading all subquery
 *       results into memory when only a single pass is needed.</li>
 * </ul>
 *
 * @see SelectExecutionPlanner#handleGlobalLet
 */
public class GlobalLetQueryStep extends AbstractExecutionStep {

  /** The variable name to store the result under. */
  private final SQLIdentifier varName;

  /** The pre-built execution plan for the subquery. */
  private final InternalExecutionPlan subExecutionPlan;

  public GlobalLetQueryStep(
      SQLIdentifier varName,
      SQLStatement query,
      CommandContext ctx,
      boolean profilingEnabled,
      List<String> scriptVars) {
    super(ctx, profilingEnabled);
    this.varName = varName;

    var subCtx = new BasicCommandContext();
    if (scriptVars != null) {
      scriptVars.forEach(subCtx::declareScriptVariable);
    }
    subCtx.setDatabaseSession(ctx.getDatabaseSession());
    subCtx.setParent(ctx);
    if (query.toString().contains("?")) {
      // with positional parameters, you cannot know if a parameter has the same ordinal as the one
      // cached
      subExecutionPlan = query.createExecutionPlanNoCache(subCtx, profilingEnabled);
    } else {
      subExecutionPlan = query.createExecutionPlan(subCtx, profilingEnabled);
    }
  }

  private GlobalLetQueryStep(
      SQLIdentifier varName,
      InternalExecutionPlan subExecutionPlan, CommandContext ctx, boolean profilingEnabled) {
    super(ctx, profilingEnabled);

    this.varName = varName;
    this.subExecutionPlan = subExecutionPlan;
  }

  @Override
  public ExecutionStream internalStart(CommandContext ctx) throws TimeoutException {
    // Drain the previous step to trigger its side effects (e.g. another global LET storing
    // its value).
    if (prev != null) {
      prev.start(ctx).close(ctx);
    }

    calculate(ctx);
    return ExecutionStream.empty();
  }

  /**
   * Executes the subquery and stores the result in the context variable.
   *
   * <p>If the variable is a planner-generated alias (from extractSubQueries) or
   * is referenced by the outer WHERE clause, the result set must be materialized
   * into a List -- because it may be iterated multiple times (once per outer record).
   * Otherwise, the lazy ResultSet is stored directly.
   */
  private void calculate(CommandContext ctx) {
    final var varName = this.varName.getStringValue();
    // Determine whether the subquery result must be materialized into a List.
    // Materialization is required in two cases:
    // 1. The variable was generated by extractSubQueries() (prefix "$$$SUBQUERY$$_")
    //    -- these are referenced inline and may be iterated multiple times.
    // 2. The variable appears in the outer WHERE clause -- the WHERE is evaluated
    //    once per outer record, so the result set must be re-iterable.
    var convertToList = varName.startsWith(SubQueryCollector.GENERATED_ALIAS_PREFIX);
    if (!convertToList) {
      for (var expr : ctx.getParentWhereExpressions()) {
        if (expr.varMightBeInUse(varName)) {
          convertToList = true;
          break;
        }
      }
    }
    final var rs = new LocalResultSet(ctx.getDatabaseSession(), subExecutionPlan);
    ctx.setVariable(varName, convertToList ? toList(rs) : rs);
  }

  private List<Result> toList(LocalResultSet oLocalResultSet) {
    List<Result> result = new ArrayList<>();
    while (oLocalResultSet.hasNext()) {
      result.add(oLocalResultSet.next());
    }
    oLocalResultSet.close();
    return result;
  }

  @Override
  public String prettyPrint(int depth, int indent) {
    var spaces = ExecutionStepInternal.getIndent(depth, indent);
    return spaces
        + "+ LET (once)\n"
        + spaces
        + "  "
        + varName
        + " = \n"
        + box(spaces + "    ", this.subExecutionPlan.prettyPrint(0, indent));
  }

  @Override
  public List<ExecutionPlan> getSubExecutionPlans() {
    return Collections.singletonList(this.subExecutionPlan);
  }

  private String box(String spaces, String s) {
    var rows = s.split("\n", -1);
    var result = new StringBuilder();
    result.append(spaces);
    result.append("+-------------------------\n");
    for (var row : rows) {
      result.append(spaces);
      result.append("| ");
      result.append(row);
      result.append("\n");
    }
    result.append(spaces);
    result.append("+-------------------------");
    return result.toString();
  }

  /** Cacheable only if the sub-execution plan is cacheable. */
  @Override
  public boolean canBeCached() {
    return subExecutionPlan != null && subExecutionPlan.canBeCached();
  }

  @Override
  public ExecutionStep copy(CommandContext ctx) {
    SQLIdentifier varNameCopy = null;
    if (varName != null) {
      varNameCopy = varName.copy();
    }
    InternalExecutionPlan subExecutionPlanCopy = null;
    if (subExecutionPlan != null) {
      subExecutionPlanCopy = subExecutionPlan.copy(ctx);
    }

    return new GlobalLetQueryStep(varNameCopy, subExecutionPlanCopy, ctx, profilingEnabled);
  }
}
