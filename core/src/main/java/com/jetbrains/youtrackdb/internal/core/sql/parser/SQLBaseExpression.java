/* Generated By:JJTree: Do not edit this line. SQLBaseExpression.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=true,NODE_PREFIX=O,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.jetbrains.youtrackdb.internal.core.sql.parser;

import com.jetbrains.youtrackdb.internal.core.command.CommandContext;
import com.jetbrains.youtrackdb.internal.core.db.DatabaseSessionEmbedded;
import com.jetbrains.youtrackdb.internal.core.db.record.record.DBRecord;
import com.jetbrains.youtrackdb.internal.core.db.record.record.Entity;
import com.jetbrains.youtrackdb.internal.core.db.record.record.Identifiable;
import com.jetbrains.youtrackdb.internal.core.exception.CommandExecutionException;
import com.jetbrains.youtrackdb.internal.core.metadata.schema.SchemaClassInternal;
import com.jetbrains.youtrackdb.internal.core.metadata.schema.schema.Collate;
import com.jetbrains.youtrackdb.internal.core.metadata.schema.schema.SchemaClass;
import com.jetbrains.youtrackdb.internal.core.query.Result;
import com.jetbrains.youtrackdb.internal.core.record.impl.EntityImpl;
import com.jetbrains.youtrackdb.internal.core.serialization.serializer.StringSerializerHelper;
import com.jetbrains.youtrackdb.internal.core.sql.executor.AggregationContext;
import com.jetbrains.youtrackdb.internal.core.sql.executor.ResultInternal;
import com.jetbrains.youtrackdb.internal.core.sql.executor.metadata.IndexMetadataPath;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Nullable;

public final class SQLBaseExpression extends SQLMathExpression {

  SQLNumber number;

  private SQLBaseIdentifier identifier;

  SQLInputParameter inputParam;

  String string;

  SQLModifier modifier;

  public SQLBaseExpression(int id) {
    super(id);
  }

  public SQLBaseExpression(YouTrackDBSql p, int id) {
    super(p, id);
  }

  public SQLBaseExpression(SQLIdentifier identifier) {
    super(-1);
    this.identifier = new SQLBaseIdentifier(identifier);
  }

  public SQLBaseExpression(String string) {
    super(-1);
    this.string = "\"" + StringSerializerHelper.encode(string) + "\"";
  }

  public SQLBaseExpression(SQLIdentifier identifier, SQLModifier modifier) {
    this(identifier);
    if (modifier != null) {
      this.modifier = modifier;
    }
  }

  public SQLBaseExpression(SQLRecordAttribute attr, SQLModifier modifier) {
    super(-1);
    this.identifier = new SQLBaseIdentifier(attr);
    if (modifier != null) {
      this.modifier = modifier;
    }
  }

  @Override
  public String toString() {
    return super.toString();
  }

  @Override
  public void toString(Map<Object, Object> params, StringBuilder builder) {
    if (number != null) {
      number.toString(params, builder);
    } else if (identifier != null) {
      identifier.toString(params, builder);
    } else if (string != null) {
      if (string.length() > 1 && string.charAt(0) == '\''
          && string.charAt(string.length() - 1) == '\'') {
        // replace quotes
        builder.append("\"").append(string, 1, string.length() - 1).append("\"");
      } else {
        builder.append(string);
      }
    } else if (inputParam != null) {
      inputParam.toString(params, builder);
    }

    if (modifier != null) {
      modifier.toString(params, builder);
    }
  }

  @Override
  public void toGenericStatement(StringBuilder builder) {
    if (number != null) {
      number.toGenericStatement(builder);
    } else if (identifier != null) {
      identifier.toGenericStatement(builder);
    } else if (string != null) {
      builder.append(PARAMETER_PLACEHOLDER);
    } else if (inputParam != null) {
      inputParam.toGenericStatement(builder);
    }
    if (modifier != null) {
      modifier.toGenericStatement(builder);
    }
  }

  // whether this expression is of type "entityField.type()"
  // these expressions are handled differently - using EntityImpl#getPropertyTypeInternal
  // instead of the standard way of doing it with SQLMethodType.
  private boolean isEntityPropertyType() {
    return this.identifier != null &&
        this.identifier.levelZero == null &&
        this.identifier.isBaseIdentifier() &&
        this.modifier != null &&
        this.modifier.methodCall != null &&
        this.modifier.methodCall.methodName != null &&
        "type".equals(this.modifier.methodCall.methodName.value) &&
        this.modifier.methodCall.params.isEmpty();
  }

  @Override
  public Object execute(Identifiable iCurrentRecord, CommandContext ctx) {
    final SQLModifier nextModifier;
    final Object result;

    if (iCurrentRecord instanceof DBRecord rec && rec.isEntity() && isEntityPropertyType()) {
      final var pType = ((EntityImpl) rec.asEntity())
          .getPropertyTypeInternal(this.identifier.suffix.identifier.value);
      result = pType == null ? null : pType.toString();
      nextModifier = this.modifier.next;
    } else {
      if (number != null) {
        result = number.getValue();
      } else if (identifier != null) {
        result = identifier.execute(iCurrentRecord, ctx);
      } else if (string != null && string.length() > 1) {
        result = StringSerializerHelper.decode(string.substring(1, string.length() - 1));
      } else if (inputParam != null) {
        result = inputParam.getValue(ctx.getInputParameters());
      } else {
        result = null;
      }

      nextModifier = this.modifier;
    }

    return nextModifier == null
        ? result
        : nextModifier.execute(iCurrentRecord, result, ctx);
  }

  @Override
  public Object execute(Result iCurrentRecord, CommandContext ctx) {
    final SQLModifier nextModifier;
    final Object result;

    if (iCurrentRecord != null && iCurrentRecord.isEntity() && isEntityPropertyType()) {
      final var pType = ((EntityImpl) iCurrentRecord.asEntity())
          .getPropertyTypeInternal(this.identifier.suffix.identifier.value);
      result = pType == null ? null : pType.toString();
      nextModifier = this.modifier.next;
    } else {

      if (number != null) {
        result = number.getValue();
      } else if (identifier != null) {
        result = identifier.execute(iCurrentRecord, ctx);
      } else if (string != null && string.length() > 1) {
        result = StringSerializerHelper.decode(string.substring(1, string.length() - 1));
      } else if (inputParam != null) {
        result = inputParam.getValue(ctx.getInputParameters());
      } else {
        result = null;
      }

      nextModifier = this.modifier;
    }

    return nextModifier == null
        ? result
        : nextModifier.execute(iCurrentRecord, result, ctx);
  }

  @Override
  protected boolean supportsBasicCalculation() {
    return true;
  }

  @Override
  public boolean isFunctionAny() {
    if (this.identifier == null) {
      return false;
    }
    return identifier.isFunctionAny();
  }

  @Override
  public boolean isFunctionAll() {
    if (this.identifier == null) {
      return false;
    }
    return identifier.isFunctionAll();
  }

  @Override
  public boolean isIndexedFunctionCall(DatabaseSessionEmbedded session) {
    if (this.identifier == null) {
      return false;
    }
    return identifier.isIndexedFunctionCall(session);
  }

  @Override
  public long estimateIndexedFunction(
      SQLFromClause target, CommandContext context, SQLBinaryCompareOperator operator,
      Object right) {
    if (this.identifier == null) {
      return -1;
    }
    return identifier.estimateIndexedFunction(target, context, operator, right);
  }

  @Override
  @Nullable
  public Iterable<Identifiable> executeIndexedFunction(
      SQLFromClause target, CommandContext context, SQLBinaryCompareOperator operator,
      Object right) {
    if (this.identifier == null) {
      return null;
    }
    return identifier.executeIndexedFunction(target, context, operator, right);
  }

  /**
   * tests if current expression is an indexed funciton AND that function can also be executed
   * without using the index
   *
   * @param target   the query target
   * @param context  the execution context
   * @param operator
   * @param right
   * @return true if current expression is an indexed funciton AND that function can also be
   * executed without using the index, false otherwise
   */
  @Override
  public boolean canExecuteIndexedFunctionWithoutIndex(
      SQLFromClause target, CommandContext context, SQLBinaryCompareOperator operator,
      Object right) {
    if (this.identifier == null) {
      return false;
    }
    return identifier.canExecuteIndexedFunctionWithoutIndex(target, context, operator, right);
  }

  /**
   * tests if current expression is an indexed function AND that function can be used on this
   * target
   *
   * @param target   the query target
   * @param context  the execution context
   * @param operator
   * @param right
   * @return true if current expression is an indexed function AND that function can be used on this
   * target, false otherwise
   */
  @Override
  public boolean allowsIndexedFunctionExecutionOnTarget(
      SQLFromClause target, CommandContext context, SQLBinaryCompareOperator operator,
      Object right) {
    if (this.identifier == null) {
      return false;
    }
    return identifier.allowsIndexedFunctionExecutionOnTarget(target, context, operator, right);
  }

  /**
   * tests if current expression is an indexed function AND the function has also to be executed
   * after the index search. In some cases, the index search is accurate, so this condition can be
   * excluded from further evaluation. In other cases the result from the index is a superset of the
   * expected result, so the function has to be executed anyway for further filtering
   *
   * @param target  the query target
   * @param context the execution context
   * @return true if current expression is an indexed function AND the function has also to be
   * executed after the index search.
   */
  @Override
  public boolean executeIndexedFunctionAfterIndexSearch(
      SQLFromClause target, CommandContext context, SQLBinaryCompareOperator operator,
      Object right) {
    if (this.identifier == null) {
      return false;
    }
    return identifier.executeIndexedFunctionAfterIndexSearch(target, context, operator, right);
  }

  @Override
  public boolean isBaseIdentifier() {
    return identifier != null && modifier == null && identifier.isBaseIdentifier();
  }

  @Override
  public boolean isGraphRelationFunction(DatabaseSessionEmbedded session) {
    return identifier != null &&
        modifier == null && identifier.isGraphRelationFunction(session);
  }

  @Nullable
  @Override
  public Collection<String> getGraphNavigationFunctionProperties(CommandContext ctx,
      SchemaClass schemaClass) {
    if (isGraphRelationFunction(ctx.getDatabaseSession())) {
      return identifier.getGraphNavigationFunctionProperties(ctx, schemaClass);
    }

    return null;
  }

  @Override
  @Nullable
  public IndexMetadataPath getIndexMetadataPath(DatabaseSessionEmbedded session) {
    if (identifier != null && (identifier.isBaseIdentifier() || identifier.isGraphRelationFunction(
        session))) {
      if (modifier != null) {
        var path = modifier.getIndexMetadataPath();

        if (path != null) {
          path.addPre(this.identifier.getSuffix().identifier.getStringValue());
          return path;
        } else {
          return null;
        }
      } else {
        return
            new IndexMetadataPath(this.identifier.getSuffix().identifier.getStringValue());
      }
    }

    return null;
  }

  @Nullable
  @Override
  public Collate getCollate(Result currentRecord, CommandContext ctx) {
    if (identifier == null) {
      return null;
    }

    if (modifier == null) {
      return identifier.getCollate(currentRecord, ctx);
    }

    if (isEntityPropertyType()) {
      // otherwise we'll get exception when working with graph in_/out_ fields,
      // when trying to access them.
      return null;
    }

    // at the moment we support collate only for chains of nested links: link1.link2.link3
    // it won't work for more complex expressions, as, for instance, coalesce(link1, link2).link3
    var record = identifier.execute(currentRecord, ctx);
    var lastModifier = modifier;
    var iterate = true;

    while (iterate) {
      if (lastModifier.suffix == null) {
        return null;
      }

      if (lastModifier.next == null) {
        iterate = false;
      } else {
        record = lastModifier.executeOneLevel(currentRecord, record, ctx);
        lastModifier = lastModifier.next;
      }
    }
    return (record instanceof Result result) ? lastModifier.suffix.getCollate(result, ctx) : null;
  }

  @Override
  public boolean isEarlyCalculated(CommandContext ctx) {
    if (number != null || inputParam != null || string != null) {
      return true;
    }
    return identifier != null && identifier.isEarlyCalculated(ctx);
  }

  @Override
  public boolean isExpand() {
    if (identifier != null) {
      return identifier.isExpand();
    }
    return false;
  }

  @Override
  public SQLExpression getExpandContent() {
    return this.identifier.getExpandContent();
  }

  @Override
  public boolean needsAliases(Set<String> aliases) {
    if (this.identifier != null && this.identifier.needsAliases(aliases)) {
      return true;
    }
    return modifier != null && modifier.needsAliases(aliases);
  }

  @Override
  public boolean isAggregate(DatabaseSessionEmbedded session) {
    return identifier != null && identifier.isAggregate(session);
  }

  @Override
  public boolean isCount() {
    return identifier != null && identifier.isCount();
  }

  @Override
  public SimpleNode splitForAggregation(
      AggregateProjectionSplit aggregateProj, CommandContext ctx) {
    if (isAggregate(ctx.getDatabaseSession())) {
      var splitResult = identifier.splitForAggregation(aggregateProj, ctx);
      if (splitResult instanceof SQLBaseIdentifier) {
        var result = new SQLBaseExpression(-1);
        result.identifier = (SQLBaseIdentifier) splitResult;
        return result;
      }
      return splitResult;
    } else {
      return this;
    }
  }

  @Override
  public AggregationContext getAggregationContext(CommandContext ctx) {
    if (identifier != null) {
      return identifier.getAggregationContext(ctx);
    } else {
      throw new CommandExecutionException(ctx.getDatabaseSession(), "cannot aggregate on " + this);
    }
  }

  @Override
  public SQLBaseExpression copy() {
    var result = new SQLBaseExpression(-1);
    result.number = number == null ? null : number.copy();
    result.identifier = identifier == null ? null : identifier.copy();
    result.inputParam = inputParam == null ? null : inputParam.copy();
    result.string = string;
    result.modifier = modifier == null ? null : modifier.copy();
    return result;
  }

  @Override
  public boolean refersToParent() {
    if (identifier != null && identifier.refersToParent()) {
      return true;
    }
    return modifier != null && modifier.refersToParent();
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }

    var that = (SQLBaseExpression) o;

    if (!Objects.equals(number, that.number)) {
      return false;
    }
    if (!Objects.equals(identifier, that.identifier)) {
      return false;
    }
    if (!Objects.equals(inputParam, that.inputParam)) {
      return false;
    }
    if (!Objects.equals(string, that.string)) {
      return false;
    }
    return Objects.equals(modifier, that.modifier);
  }

  @Override
  public int hashCode() {
    var result = number != null ? number.hashCode() : 0;
    result = 31 * result + (identifier != null ? identifier.hashCode() : 0);
    result = 31 * result + (inputParam != null ? inputParam.hashCode() : 0);
    result = 31 * result + (string != null ? string.hashCode() : 0);
    result = 31 * result + (modifier != null ? modifier.hashCode() : 0);
    return result;
  }

  public void setIdentifier(SQLBaseIdentifier identifier) {
    this.identifier = identifier;
  }

  public SQLBaseIdentifier getIdentifier() {
    return identifier;
  }

  public SQLModifier getModifier() {
    return modifier;
  }

  @Override
  public List<String> getMatchPatternInvolvedAliases() {
    if (this.identifier != null && this.identifier.toString().equals("$matched")) {
      if (modifier != null && modifier.suffix != null && modifier.suffix.getIdentifier() != null) {
        return Collections.singletonList(modifier.suffix.getIdentifier().toString());
      }
    }
    return Collections.emptyList();
  }

  @Override
  public void applyRemove(ResultInternal result, CommandContext ctx) {
    if (identifier != null) {
      if (modifier == null) {
        identifier.applyRemove(result, ctx);
      } else {
        var val = identifier.execute(result, ctx);
        modifier.applyRemove(val, result, ctx);
      }
    }
  }

  @Override
  public Result serialize(DatabaseSessionEmbedded session) {
    var result = (ResultInternal) super.serialize(session);

    if (number != null) {
      result.setProperty("number", number.serialize(session));
    }
    if (identifier != null) {
      result.setProperty("identifier", identifier.serialize(session));
    }
    if (inputParam != null) {
      result.setProperty("inputParam", inputParam.serialize(session));
    }
    if (string != null) {
      result.setProperty("string", string);
    }
    if (modifier != null) {
      result.setProperty("modifier", modifier.serialize(session));
    }
    return result;
  }

  @Override
  public void deserialize(Result fromResult) {
    super.deserialize(fromResult);

    if (fromResult.getProperty("number") != null) {
      number = new SQLNumber(-1);
      number.deserialize(fromResult.getProperty("number"));
    }
    if (fromResult.getProperty("identifier") != null) {
      identifier = new SQLBaseIdentifier(-1);
      identifier.deserialize(fromResult.getProperty("identifier"));
    }
    if (fromResult.getProperty("inputParam") != null) {
      inputParam = SQLInputParameter.deserializeFromOResult(fromResult.getProperty("inputParam"));
    }

    if (fromResult.getProperty("string") != null) {
      string = fromResult.getProperty("string");
    }
    if (fromResult.getProperty("modifier") != null) {
      modifier = new SQLModifier(-1);
      modifier.deserialize(fromResult.getProperty("modifier"));
    }
  }

  @Override
  public boolean isDefinedFor(Result currentRecord) {
    if (this.identifier != null) {
      if (modifier == null) {
        return identifier.isDefinedFor(currentRecord);
      }
    }
    return true;
  }

  @Override
  public boolean isDefinedFor(DatabaseSessionEmbedded db, Entity currentRecord) {
    if (this.identifier != null) {
      if (modifier == null) {
        return identifier.isDefinedFor(db, currentRecord);
      }
    }
    return true;
  }

  @Override
  public void extractSubQueries(SQLIdentifier letAlias, SubQueryCollector collector) {
    if (this.identifier != null) {
      this.identifier.extractSubQueries(letAlias, collector);
    }
  }

  @Override
  public void extractSubQueries(SubQueryCollector collector) {
    if (this.identifier != null) {
      this.identifier.extractSubQueries(collector);
    }
  }

  @Override
  public boolean isCacheable(DatabaseSessionEmbedded session) {
    if (modifier != null && !modifier.isCacheable(session)) {
      return false;
    }
    if (identifier != null) {
      return identifier.isCacheable(session);
    }

    return true;
  }

  public void setInputParam(SQLInputParameter inputParam) {
    this.inputParam = inputParam;
  }

  @Override
  public boolean isIndexChain(CommandContext ctx, SchemaClassInternal clazz) {
    if (modifier == null) {
      return false;
    }
    var db = ctx.getDatabaseSession();
    if (identifier.isIndexChain(clazz)) {
      var prop = clazz.getProperty(
          identifier.getSuffix().getIdentifier().getStringValue());
      var linkedClass = (SchemaClassInternal) prop.getLinkedClass();
      if (linkedClass != null) {
        return modifier.isIndexChain(ctx, linkedClass);
      }
    }
    return false;
  }

  @Override
  public boolean varMightBeInUse(String varName) {
    return super.varMightBeInUse(varName) ||
        identifier != null && identifier.varMightBeInUse(varName) ||
        modifier != null && modifier.varMightBeInUse(varName);
  }
}

/* JavaCC - OriginalChecksum=71b3e2d1b65c923dc7cfe11f9f449d2b (do not edit this line) */
