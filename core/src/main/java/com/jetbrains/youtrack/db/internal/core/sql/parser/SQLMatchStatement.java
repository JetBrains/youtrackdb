/* Generated By:JJTree: Do not edit this line. SQLMatchStatement.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=true,NODE_PREFIX=O,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.jetbrains.youtrack.db.internal.core.sql.parser;

import com.jetbrains.youtrack.db.api.exception.CommandExecutionException;
import com.jetbrains.youtrack.db.api.exception.RecordNotFoundException;
import com.jetbrains.youtrack.db.api.query.ResultSet;
import com.jetbrains.youtrack.db.api.record.Identifiable;
import com.jetbrains.youtrack.db.api.schema.Schema;
import com.jetbrains.youtrack.db.api.schema.SchemaClass;
import com.jetbrains.youtrack.db.internal.common.util.PairLongObject;
import com.jetbrains.youtrack.db.internal.core.command.BasicCommandContext;
import com.jetbrains.youtrack.db.internal.core.command.CommandContext;
import com.jetbrains.youtrack.db.internal.core.db.DatabaseSessionEmbedded;
import com.jetbrains.youtrack.db.internal.core.db.DatabaseSessionInternal;
import com.jetbrains.youtrack.db.internal.core.metadata.schema.SchemaImmutableClass;
import com.jetbrains.youtrack.db.internal.core.record.impl.EntityImpl;
import com.jetbrains.youtrack.db.internal.core.sql.IterableRecordSource;
import com.jetbrains.youtrack.db.internal.core.sql.executor.InternalExecutionPlan;
import com.jetbrains.youtrack.db.internal.core.sql.executor.MatchExecutionPlanner;
import com.jetbrains.youtrack.db.internal.core.sql.executor.PatternEdge;
import com.jetbrains.youtrack.db.internal.core.sql.executor.PatternNode;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import javax.annotation.Nullable;

public final class SQLMatchStatement extends SQLStatement implements IterableRecordSource {

  static final String DEFAULT_ALIAS_PREFIX = "$YOUTRACKDB_DEFAULT_ALIAS_";

  public static final String KEYWORD_MATCH = "MATCH";
  // parsed data
  private List<SQLMatchExpression> matchExpressions = new ArrayList<>();
  private List<SQLMatchExpression> notMatchExpressions = new ArrayList<>();
  private List<SQLExpression> returnItems = new ArrayList<>();
  private List<SQLIdentifier> returnAliases = new ArrayList<>();
  private List<SQLNestedProjection> returnNestedProjections = new ArrayList<>();
  boolean returnDistinct = false;
  SQLGroupBy groupBy;
  SQLOrderBy orderBy;
  SQLUnwind unwind;
  SQLSkip skip;
  SQLLimit limit;

  // post-parsing generated data
  Pattern pattern;

  private Map<String, SQLWhereClause> aliasFilters;

  // execution data
  private CommandContext context;

  public List<SQLNestedProjection> getReturnNestedProjections() {
    return returnNestedProjections;
  }

  public void setContext(CommandContext context) {
    this.context = context;
  }

  public void setReturnNestedProjections(List<SQLNestedProjection> returnNestedProjections) {
    this.returnNestedProjections = returnNestedProjections;
  }

  public void addMatchExpression(SQLMatchExpression exp) {
    this.matchExpressions.add(exp);
  }

  public void addNotMatchExpression(SQLMatchExpression exp) {
    this.notMatchExpressions.add(exp);
  }

  public void addReturnNestedProjection(SQLNestedProjection projection) {
    this.returnNestedProjections.add(projection);
  }

  public void addReturnItem(SQLExpression item) {
    this.returnItems.add(item);
  }

  public void addReturnAlias(SQLIdentifier alias) {
    this.returnAliases.add(alias);
  }

  public static class MatchContext {

    int currentEdgeNumber = 0;

    LinkedHashMap<Object, Iterable<Identifiable>> candidates = new LinkedHashMap<>();
    Map<String, Identifiable> matched = new LinkedHashMap<>();
    Map<PatternEdge, Boolean> matchedEdges = new IdentityHashMap<>();

    public MatchContext copy(String alias, Identifiable value) {
      var result = new MatchContext();

      result.candidates.putAll(candidates);
      result.candidates.remove(alias);

      result.matched.putAll(matched);
      result.matched.put(alias, value);

      result.matchedEdges.putAll(matchedEdges);
      result.currentEdgeNumber = currentEdgeNumber;
      return result;
    }
  }

  public static class EdgeTraversal {

    private boolean out = true;
    private final PatternEdge edge;

    public EdgeTraversal(PatternEdge edge, boolean out) {
      this.edge = edge;
      this.out = out;
    }
  }

  public SQLMatchStatement() {
    super(-1);
  }

  public SQLMatchStatement(int id) {
    super(id);
  }

  public SQLMatchStatement(YouTrackDBSql p, int id) {
    super(p, id);
  }

  @Override
  public ResultSet execute(
      DatabaseSessionEmbedded session, Object[] args, CommandContext parentCtx,
      boolean usePlanCache) {
    var ctx = new BasicCommandContext();
    if (parentCtx != null) {
      ctx.setParentWithoutOverridingChild(parentCtx);
    }
    ctx.setDatabaseSession(session);
    Map<Object, Object> params = new HashMap<>();
    if (args != null) {
      for (var i = 0; i < args.length; i++) {
        params.put(i, args[i]);
      }
    }
    ctx.setInputParameters(params);
    InternalExecutionPlan executionPlan;
    if (usePlanCache) {
      executionPlan = createExecutionPlan(ctx, false);
    } else {
      executionPlan = createExecutionPlanNoCache(ctx, false);
    }

    return new LocalResultSet(session, executionPlan);
  }

  @Override
  public ResultSet execute(
      DatabaseSessionEmbedded session, Map<Object, Object> params, CommandContext parentCtx,
      boolean usePlanCache) {
    var ctx = new BasicCommandContext();
    if (parentCtx != null) {
      ctx.setParentWithoutOverridingChild(parentCtx);
    }
    ctx.setDatabaseSession(session);
    ctx.setInputParameters(params);
    InternalExecutionPlan executionPlan;
    if (usePlanCache) {
      executionPlan = createExecutionPlan(ctx, false);
    } else {
      executionPlan = createExecutionPlanNoCache(ctx, false);
    }

    return new LocalResultSet(session, executionPlan);
  }

  @Override
  public InternalExecutionPlan createExecutionPlan(CommandContext ctx, boolean enableProfiling) {
    var planner = new MatchExecutionPlanner(this);
    var result = planner.createExecutionPlan(ctx, enableProfiling);
    result.setStatement(originalStatement);
    result.setGenericStatement(this.toGenericStatement());
    return result;
  }

  // ------------------------------------------------------------------
  // query parsing and optimization
  // ------------------------------------------------------------------
  void buildPatterns() {
    assignDefaultAliases(this.matchExpressions);
    pattern = new Pattern();
    for (var expr : this.matchExpressions) {
      pattern.addExpression(expr);
    }

    Map<String, SQLWhereClause> aliasFilters = new LinkedHashMap<String, SQLWhereClause>();
    Map<String, String> aliasClasses = new LinkedHashMap<String, String>();
    for (var expr : this.matchExpressions) {
      addAliases(expr, aliasFilters, aliasClasses, context);
    }

    this.aliasFilters = aliasFilters;

    rebindFilters(aliasFilters);
  }

  /**
   * rebinds filter (where) conditions to alias nodes after optimization
   */
  private void rebindFilters(Map<String, SQLWhereClause> aliasFilters) {
    for (var expression : matchExpressions) {
      var newFilter = aliasFilters.get(expression.origin.getAlias());
      expression.origin.setFilter(newFilter);

      for (var item : expression.items) {
        newFilter = aliasFilters.get(item.filter.getAlias());
        item.filter.setFilter(newFilter);
      }
    }
  }

  /**
   * assigns default aliases to pattern nodes that do not have an explicit alias
   */
  private static void assignDefaultAliases(List<SQLMatchExpression> matchExpressions) {
    var counter = 0;
    for (var expression : matchExpressions) {
      if (expression.origin.getAlias() == null) {
        expression.origin.setAlias(DEFAULT_ALIAS_PREFIX + (counter++));
      }

      for (var item : expression.items) {
        if (item.filter == null) {
          item.filter = new SQLMatchFilter(-1);
        }
        if (item.filter.getAlias() == null) {
          item.filter.setAlias(DEFAULT_ALIAS_PREFIX + (counter++));
        }
      }
    }
  }

  /**
   * Start a depth-first traversal from the starting node, adding all viable unscheduled edges and
   * vertices.
   *
   * @param startNode             the node from which to start the depth-first traversal
   * @param visitedNodes          set of nodes that are already visited (mutated in this function)
   * @param visitedEdges          set of edges that are already visited and therefore don't need to
   *                              be scheduled (mutated in this function)
   * @param remainingDependencies dependency map including only the dependencies that haven't yet
   *                              been satisfied (mutated in this function)
   * @param resultingSchedule     the schedule being computed i.e. appended to (mutated in this
   *                              function)
   */
  private static void updateScheduleStartingAt(
      PatternNode startNode,
      Set<PatternNode> visitedNodes,
      Set<PatternEdge> visitedEdges,
      Map<String, Set<String>> remainingDependencies,
      List<EdgeTraversal> resultingSchedule) {
    // YouTrackDB requires the schedule to contain all edges present in the query, which is a stronger
    // condition
    // than simply visiting all nodes in the query. Consider the following example query:
    //     MATCH {
    //         class: A,
    //         as: foo
    //     }.in() {
    //         as: bar
    //     }, {
    //         class: B,
    //         as: bar
    //     }.out() {
    //         as: foo
    //     } RETURN $matches
    // The schedule for the above query must have two edges, even though there are only two nodes
    // and they can both
    // be visited with the traversal of a single edge.
    //
    // To satisfy it, we obey the following for each non-optional node:
    // - ignore edges to neighboring nodes which have unsatisfied dependencies;
    // - for visited neighboring nodes, add their edge if it wasn't already present in the schedule,
    // but do not
    //   recurse into the neighboring node;
    // - for unvisited neighboring nodes with satisfied dependencies, add their edge and recurse
    // into them.
    visitedNodes.add(startNode);
    for (var dependencies : remainingDependencies.values()) {
      dependencies.remove(startNode.alias);
    }

    Map<PatternEdge, Boolean> edges = new LinkedHashMap<PatternEdge, Boolean>();
    for (var outEdge : startNode.out) {
      edges.put(outEdge, true);
    }
    for (var inEdge : startNode.in) {
      edges.put(inEdge, false);
    }

    for (var edgeData : edges.entrySet()) {
      var edge = edgeData.getKey();
      boolean isOutbound = edgeData.getValue();
      var neighboringNode = isOutbound ? edge.in : edge.out;

      if (!remainingDependencies.get(neighboringNode.alias).isEmpty()) {
        // Unsatisfied dependencies, ignore this neighboring node.
        continue;
      }

      if (visitedNodes.contains(neighboringNode)) {
        if (!visitedEdges.contains(edge)) {
          // If we are executing in this block, we are in the following situation:
          // - the startNode has not been visited yet;
          // - it has a neighboringNode that has already been visited;
          // - the edge between the startNode and the neighboringNode has not been scheduled yet.
          //
          // The isOutbound value shows us whether the edge is outbound from the point of view of
          // the startNode.
          // However, if there are edges to the startNode, we must visit the startNode from an
          // already-visited
          // neighbor, to preserve the validity of the traversal. Therefore, we negate the value of
          // isOutbound
          // to ensure that the edge is always scheduled in the direction from the already-visited
          // neighbor
          // toward the startNode. Notably, this is also the case when evaluating "optional" nodes
          // -- we always
          // visit the optional node from its non-optional and already-visited neighbor.
          //
          // The only exception to the above is when we have edges with "while" conditions. We are
          // not allowed
          // to flip their directionality, so we leave them as-is.
          boolean traversalDirection;
          if (startNode.optional || edge.item.isBidirectional()) {
            traversalDirection = !isOutbound;
          } else {
            traversalDirection = isOutbound;
          }

          visitedEdges.add(edge);
          resultingSchedule.add(new EdgeTraversal(edge, traversalDirection));
        }
      } else if (!startNode.optional) {
        // If the neighboring node wasn't visited, we don't expand the optional node into it, hence
        // the above check.
        // Instead, we'll allow the neighboring node to add the edge we failed to visit, via the
        // above block.
        if (visitedEdges.contains(edge)) {
          // Should never happen.
          throw new AssertionError(
              "The edge was visited, but the neighboring vertex was not: "
                  + edge
                  + " "
                  + neighboringNode);
        }

        visitedEdges.add(edge);
        resultingSchedule.add(new EdgeTraversal(edge, isOutbound));
        updateScheduleStartingAt(
            neighboringNode, visitedNodes, visitedEdges, remainingDependencies, resultingSchedule);
      }
    }
  }

  /**
   * Calculate the set of dependency aliases for each alias in the pattern.
   *
   * @return map of alias to the set of aliases it depends on
   */
  private Map<String, Set<String>> getDependencies(Pattern pattern) {
    Map<String, Set<String>> result = new HashMap<String, Set<String>>();

    for (var node : pattern.aliasToNode.values()) {
      Set<String> currentDependencies = new HashSet<String>();

      var filter = aliasFilters.get(node.alias);
      if (filter != null && filter.baseExpression != null) {
        var involvedAliases = filter.baseExpression.getMatchPatternInvolvedAliases();
        if (involvedAliases != null) {
          currentDependencies.addAll(involvedAliases);
        }
      }

      result.put(node.alias, currentDependencies);
    }

    return result;
  }

  /**
   * sort edges in the order they will be matched
   */
  private List<EdgeTraversal> getTopologicalSortedSchedule(
      Map<String, Long> estimatedRootEntries, Pattern pattern) {
    List<EdgeTraversal> resultingSchedule = new ArrayList<EdgeTraversal>();
    var remainingDependencies = getDependencies(pattern);
    Set<PatternNode> visitedNodes = new HashSet<PatternNode>();
    Set<PatternEdge> visitedEdges = new HashSet<PatternEdge>();

    // Sort the possible root vertices in order of estimated size, since we want to start with a
    // small vertex set.
    List<PairLongObject<String>> rootWeights = new ArrayList<>();
    for (var root : estimatedRootEntries.entrySet()) {
      rootWeights.add(new PairLongObject<>(root.getValue(), root.getKey()));
    }
    Collections.sort(rootWeights);

    // Add the starting vertices, in the correct order, to an ordered set.
    Set<String> remainingStarts = new LinkedHashSet<String>();
    for (var item : rootWeights) {
      remainingStarts.add(item.getValue());
    }
    // Add all the remaining aliases after all the suggested start points.
    remainingStarts.addAll(pattern.aliasToNode.keySet());

    while (resultingSchedule.size() < pattern.numOfEdges) {
      // Start a new depth-first pass, adding all nodes with satisfied dependencies.
      // 1. Find a starting vertex for the depth-first pass.
      PatternNode startingNode = null;
      List<String> startsToRemove = new ArrayList<String>();
      for (var currentAlias : remainingStarts) {
        var currentNode = pattern.aliasToNode.get(currentAlias);

        if (visitedNodes.contains(currentNode)) {
          // If a previous traversal already visited this alias, remove it from further
          // consideration.
          startsToRemove.add(currentAlias);
        } else if (remainingDependencies.get(currentAlias).isEmpty()) {
          // If it hasn't been visited, and has all dependencies satisfied, visit it.
          startsToRemove.add(currentAlias);
          startingNode = currentNode;
          break;
        }
      }
      startsToRemove.forEach(remainingStarts::remove);

      if (startingNode == null) {
        // We didn't manage to find a valid root, and yet we haven't constructed a complete
        // schedule.
        // This means there must be a cycle in our dependency graph, or all dependency-free nodes
        // are optional.
        // Therefore, the query is invalid.
        throw new CommandExecutionException(
            "This query contains MATCH conditions that cannot be evaluated, "
                + "like an undefined alias or a circular dependency on a $matched condition.");
      }

      // 2. Having found a starting vertex, traverse its neighbors depth-first,
      //    adding any non-visited ones with satisfied dependencies to our schedule.
      updateScheduleStartingAt(
          startingNode, visitedNodes, visitedEdges, remainingDependencies, resultingSchedule);
    }

    if (resultingSchedule.size() != pattern.numOfEdges) {
      throw new AssertionError(
          "Incorrect number of edges: " + resultingSchedule.size() + " vs " + pattern.numOfEdges);
    }

    return resultingSchedule;
  }


  private static boolean matchesClass(DatabaseSessionInternal session, Identifiable identifiable,
      SchemaClass oClass) {
    if (identifiable == null) {
      return false;
    }
    try {
      var transaction = session.getActiveTransaction();
      var record = transaction.load(identifiable);
      if (record instanceof EntityImpl) {
        SchemaImmutableClass result;
        result = ((EntityImpl) record).getImmutableSchemaClass(session);
        SchemaClass schemaClass = result;
        if (schemaClass == null) {
          return false;
        }
        return schemaClass.isSubClassOf(oClass);
      }
      return false;
    } catch (RecordNotFoundException rnf) {
      return false;
    }
  }

  public boolean returnsPathElements() {
    for (var item : returnItems) {
      if (item.toString().equalsIgnoreCase("$pathElements")) {
        return true;
      }
    }
    return false;
  }

  public boolean returnsElements() {
    for (var item : returnItems) {
      if (item.toString().equalsIgnoreCase("$elements")) {
        return true;
      }
    }
    return false;
  }

  public boolean returnsPatterns() {
    for (var item : returnItems) {
      if (item.toString().equalsIgnoreCase("$patterns")) {
        return true;
      }
      if (item.toString().equalsIgnoreCase("$matches")) {
        return true;
      }
    }
    return false;
  }

  public boolean returnsPaths() {
    for (var item : returnItems) {
      if (item.toString().equalsIgnoreCase("$paths")) {
        return true;
      }
    }
    return false;
  }


  private static void addAliases(
      SQLMatchExpression expr,
      Map<String, SQLWhereClause> aliasFilters,
      Map<String, String> aliasClasses,
      CommandContext context) {
    addAliases(expr.origin, aliasFilters, aliasClasses, context);
    for (var item : expr.items) {
      if (item.filter != null) {
        addAliases(item.filter, aliasFilters, aliasClasses, context);
      }
    }
  }

  private static void addAliases(
      SQLMatchFilter matchFilter,
      Map<String, SQLWhereClause> aliasFilters,
      Map<String, String> aliasClasses,
      CommandContext context) {
    var db = context.getDatabaseSession();
    var alias = matchFilter.getAlias();
    var filter = matchFilter.getFilter();
    if (alias != null) {
      if (filter != null && filter.baseExpression != null) {
        var previousFilter = aliasFilters.get(alias);
        if (previousFilter == null) {
          previousFilter = new SQLWhereClause(-1);
          previousFilter.baseExpression = new SQLAndBlock(-1);
          aliasFilters.put(alias, previousFilter);
        }
        var filterBlock = (SQLAndBlock) previousFilter.baseExpression;
        if (filter.baseExpression != null) {
          filterBlock.subBlocks.add(filter.baseExpression);
        }
      }

      var clazz = matchFilter.getClassName(context);
      if (clazz != null) {
        var previousClass = aliasClasses.get(alias);
        if (previousClass == null) {
          aliasClasses.put(alias, clazz);
        } else {
          var lower = getLowerSubclass(db, clazz, previousClass);
          if (lower == null) {
            throw new CommandExecutionException(
                "classes defined for alias "
                    + alias
                    + " ("
                    + clazz
                    + ", "
                    + previousClass
                    + ") are not in the same hierarchy");
          }
          aliasClasses.put(alias, lower);
        }
      }
    }
  }

  @Nullable
  private static String getLowerSubclass(DatabaseSessionInternal session, String className1,
      String className2) {
    Schema schema = session.getMetadata().getSchema();
    var class1 = schema.getClass(className1);
    var class2 = schema.getClass(className2);
    if (class1 == null) {
      throw new CommandExecutionException(session,
          "Class " + className1 + " not found in the schema");
    }
    if (class2 == null) {
      throw new CommandExecutionException(session,
          "Class " + className2 + " not found in the schema");
    }
    if (class1.isSubClassOf(class2)) {
      return class1.getName();
    }
    if (class2.isSubClassOf(class1)) {
      return class2.getName();
    }
    return null;
  }

  @Override
  public boolean isIdempotent() {
    return true;
  }

  public void toString(Map<Object, Object> params, StringBuilder builder) {
    builder.append(KEYWORD_MATCH);
    builder.append(" ");
    var first = true;
    for (var expr : this.matchExpressions) {
      if (!first) {
        builder.append(", ");
      }
      expr.toString(params, builder);
      first = false;
    }
    builder.append(" RETURN ");
    if (returnDistinct) {
      builder.append("DISTINCT ");
    }
    first = true;
    var i = 0;
    for (var expr : this.returnItems) {
      if (!first) {
        builder.append(", ");
      }
      expr.toString(params, builder);
      if (returnNestedProjections != null
          && i < returnNestedProjections.size()
          && returnNestedProjections.get(i) != null) {
        returnNestedProjections.get(i).toString(params, builder);
      }
      if (returnAliases != null && i < returnAliases.size() && returnAliases.get(i) != null) {
        builder.append(" AS ");
        returnAliases.get(i).toString(params, builder);
      }
      i++;
      first = false;
    }
    if (groupBy != null) {
      builder.append(" ");
      groupBy.toString(params, builder);
    }
    if (orderBy != null) {
      builder.append(" ");
      orderBy.toString(params, builder);
    }
    if (unwind != null) {
      builder.append(" ");
      unwind.toString(params, builder);
    }
    if (skip != null) {
      builder.append(" ");
      skip.toString(params, builder);
    }
    if (limit != null) {
      builder.append(" ");
      limit.toString(params, builder);
    }
  }

  public void toGenericStatement(StringBuilder builder) {
    builder.append(KEYWORD_MATCH);
    builder.append(" ");
    var first = true;
    for (var expr : this.matchExpressions) {
      if (!first) {
        builder.append(", ");
      }
      expr.toGenericStatement(builder);
      first = false;
    }
    builder.append(" RETURN ");
    if (returnDistinct) {
      builder.append("DISTINCT ");
    }
    first = true;
    var i = 0;
    for (var expr : this.returnItems) {
      if (!first) {
        builder.append(", ");
      }
      expr.toGenericStatement(builder);
      if (returnNestedProjections != null
          && i < returnNestedProjections.size()
          && returnNestedProjections.get(i) != null) {
        returnNestedProjections.get(i).toGenericStatement(builder);
      }
      if (returnAliases != null && i < returnAliases.size() && returnAliases.get(i) != null) {
        builder.append(" AS ");
        returnAliases.get(i).toGenericStatement(builder);
      }
      i++;
      first = false;
    }
    if (groupBy != null) {
      builder.append(" ");
      groupBy.toGenericStatement(builder);
    }
    if (orderBy != null) {
      builder.append(" ");
      orderBy.toGenericStatement(builder);
    }
    if (unwind != null) {
      builder.append(" ");
      unwind.toGenericStatement(builder);
    }
    if (skip != null) {
      builder.append(" ");
      skip.toGenericStatement(builder);
    }
    if (limit != null) {
      builder.append(" ");
      limit.toGenericStatement(builder);
    }
  }

  @Override
  public Iterator<Identifiable> iterator(DatabaseSessionEmbedded session,
      Map<Object, Object> iArgs) {
    if (context == null) {
      var context = new BasicCommandContext();
      context.setDatabaseSession(session);

      this.context = context;
    }

    var result = execute(session, iArgs);
    return result.stream().map(x -> (Identifiable) x.getIdentity()).iterator();
  }

  @Override
  public SQLMatchStatement copy() {
    var result = new SQLMatchStatement(-1);
    //noinspection ReturnOfNull
    result.matchExpressions =
        matchExpressions == null
            ? null
            : matchExpressions.stream()
                .map(x -> x == null ? null : x.copy())
                .collect(Collectors.toList());
    //noinspection ReturnOfNull
    result.notMatchExpressions =
        notMatchExpressions == null
            ? null
            : notMatchExpressions.stream()
                .map(x -> x == null ? null : x.copy())
                .collect(Collectors.toList());
    //noinspection ReturnOfNull
    result.returnItems =
        returnItems == null
            ? null
            : returnItems.stream()
                .map(x -> x == null ? null : x.copy())
                .collect(Collectors.toList());
    //noinspection ReturnOfNull
    result.returnAliases =
        returnAliases == null
            ? null
            : returnAliases.stream()
                .map(x -> x == null ? null : x.copy())
                .collect(Collectors.toList());
    //noinspection ReturnOfNull
    result.returnNestedProjections =
        returnNestedProjections == null
            ? null
            : returnNestedProjections.stream()
                .map(x -> x == null ? null : x.copy())
                .collect(Collectors.toList());
    result.groupBy = groupBy == null ? null : groupBy.copy();
    result.orderBy = orderBy == null ? null : orderBy.copy();
    result.unwind = unwind == null ? null : unwind.copy();
    result.skip = skip == null ? null : skip.copy();
    result.limit = limit == null ? null : limit.copy();
    result.returnDistinct = this.returnDistinct;
    result.buildPatterns();
    return result;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }

    var that = (SQLMatchStatement) o;

    if (!Objects.equals(matchExpressions, that.matchExpressions)) {
      return false;
    }
    if (!Objects.equals(notMatchExpressions, that.notMatchExpressions)) {
      return false;
    }
    if (!Objects.equals(returnItems, that.returnItems)) {
      return false;
    }
    if (!Objects.equals(returnAliases, that.returnAliases)) {
      return false;
    }
    if (!Objects.equals(returnNestedProjections, that.returnNestedProjections)) {
      return false;
    }
    if (!Objects.equals(groupBy, that.groupBy)) {
      return false;
    }
    if (!Objects.equals(orderBy, that.orderBy)) {
      return false;
    }
    if (!Objects.equals(unwind, that.unwind)) {
      return false;
    }
    if (!Objects.equals(skip, that.skip)) {
      return false;
    }
    if (!Objects.equals(limit, that.limit)) {
      return false;
    }

    return returnDistinct == that.returnDistinct;
  }

  @Override
  public int hashCode() {
    var result = matchExpressions != null ? matchExpressions.hashCode() : 0;
    result = 31 * result + (notMatchExpressions != null ? notMatchExpressions.hashCode() : 0);
    result = 31 * result + (returnItems != null ? returnItems.hashCode() : 0);
    result = 31 * result + (returnAliases != null ? returnAliases.hashCode() : 0);
    result =
        31 * result + (returnNestedProjections != null ? returnNestedProjections.hashCode() : 0);
    result = 31 * result + (groupBy != null ? groupBy.hashCode() : 0);
    result = 31 * result + (orderBy != null ? orderBy.hashCode() : 0);
    result = 31 * result + (unwind != null ? unwind.hashCode() : 0);
    result = 31 * result + (skip != null ? skip.hashCode() : 0);
    result = 31 * result + (limit != null ? limit.hashCode() : 0);
    return result;
  }

  public SQLLimit getLimit() {
    return limit;
  }

  public void setLimit(SQLLimit limit) {
    this.limit = limit;
  }

  public List<SQLIdentifier> getReturnAliases() {
    return returnAliases;
  }

  public void setReturnAliases(List<SQLIdentifier> returnAliases) {
    this.returnAliases = returnAliases;
  }

  public List<SQLExpression> getReturnItems() {
    return returnItems;
  }

  public void setReturnItems(List<SQLExpression> returnItems) {
    this.returnItems = returnItems;
  }

  public List<SQLMatchExpression> getMatchExpressions() {
    return matchExpressions;
  }

  public void setMatchExpressions(List<SQLMatchExpression> matchExpressions) {
    this.matchExpressions = matchExpressions;
  }

  public List<SQLMatchExpression> getNotMatchExpressions() {
    return notMatchExpressions;
  }

  public void setNotMatchExpressions(List<SQLMatchExpression> notMatchExpressions) {
    this.notMatchExpressions = notMatchExpressions;
  }

  public boolean isReturnDistinct() {
    return returnDistinct;
  }

  public void setReturnDistinct(boolean returnDistinct) {
    this.returnDistinct = returnDistinct;
  }

  public SQLOrderBy getOrderBy() {
    return orderBy;
  }

  public void setOrderBy(SQLOrderBy orderBy) {
    this.orderBy = orderBy;
  }

  public SQLGroupBy getGroupBy() {
    return groupBy;
  }

  public void setGroupBy(SQLGroupBy groupBy) {
    this.groupBy = groupBy;
  }

  public SQLUnwind getUnwind() {
    return unwind;
  }

  public void setUnwind(SQLUnwind unwind) {
    this.unwind = unwind;
  }

  public SQLSkip getSkip() {
    return skip;
  }

  public void setSkip(SQLSkip skip) {
    this.skip = skip;
  }

  @Override
  public boolean refersToParent() {
    // TODO check this!
    return false;
  }
}
/* JavaCC - OriginalChecksum=6ff0afbe9d31f08b72159fcf24070c9f (do not edit this line) */
